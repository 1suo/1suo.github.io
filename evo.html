<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Evolutionary SVG — Vanilla</title>
    <style>
      :root {
        --gap: 10px;
        --cell-bg: #0d0f12;
        --accent: #6ee7b7;
        --fg: #e5e7eb;
        --mut-1: #60a5fa;
        --mut-2: #f59e0b;
        --mut-3: #ef4444;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #0b0c10;
        color: var(--fg);
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Ubuntu,
          Cantarell,
          Noto Sans,
          Helvetica Neue,
          Arial;
      }
      header {
        padding: 14px 16px;
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
        position: sticky;
        top: 0;
        background: rgba(11, 12, 16, 0.85);
        backdrop-filter: blur(8px);
        border-bottom: 1px solid #111827;
        z-index: 5;
      }
      header h1 {
        font-size: 16px;
        font-weight: 600;
        margin: 0;
        letter-spacing: 0.3px;
      }
      header .spacer {
        flex: 1;
      }
      button,
      .btn {
        background: #111827;
        color: var(--fg);
        border: 1px solid #1f2937;
        border-radius: 12px;
        padding: 10px 14px;
        font-size: 14px;
        cursor: pointer;
        transition: 0.2s ease;
        display: inline-flex;
        gap: 8px;
        align-items: center;
      }
      button:hover {
        border-color: #374151;
        transform: translateY(-1px);
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .tag {
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid #1f2937;
      }
      .tag.blue {
        color: var(--mut-1);
        border-color: #1e3a8a;
      }
      .tag.amber {
        color: var(--mut-2);
        border-color: #78350f;
      }
      .tag.red {
        color: var(--mut-3);
        border-color: #7f1d1d;
      }

      main {
        padding: 12px;
      }
      .grid {
        width: min(1100px, 100%);
        margin: 0 auto;
        display: grid;
        gap: var(--gap);
        grid-template-columns: repeat(3, 1fr);
        grid-auto-rows: 1fr;
      }
      .cell {
        background: var(--cell-bg);
        border: 1px solid #111827;
        border-radius: 14px;
        overflow: hidden;
        position: relative;
        aspect-ratio: 1 / 1;
        display: grid;
        place-items: center;
        cursor: pointer;
        transition: transform 0.15s ease;
      }
      .cell:hover {
        transform: translateY(-2px);
      }
      .cell svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .badge {
        position: absolute;
        left: 10px;
        top: 10px;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 10px;
        border: 1px solid #1f2937;
        background: rgba(17, 24, 39, 0.55);
      }
      .center .badge {
        border-color: #064e3b;
        color: var(--accent);
      }
      .legend {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }

      @media (max-width: 720px) {
        header {
          gap: 8px;
        }
        .grid {
          gap: 8px;
        }
        .cell {
          border-radius: 10px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Evolutionary SVG — User‑Driven Genetic Art</h1>
      <div class="spacer"></div>
      <div class="legend">
        <span class="tag">Parent</span>
        <span class="tag blue">P=0.1</span>
        <span class="tag amber">P=0.3</span>
        <span class="tag red">P=0.5</span>
      </div>
      <div class="spacer"></div>
      <div class="row">
        <button id="saveSvg">Save SVG</button>
        <button id="savePng">Save PNG</button>
        <button id="randomize">Randomize Parent</button>
        <button id="exportGen">Export Genotype</button>
        <button id="importGen">Import Genotype</button>
      </div>
    </header>

    <main>
      <div id="grid" class="grid"></div>
    </main>

    <script>
      /**********************
       * Utility helpers
       **********************/
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const rand = (a = 0, b = 1) => a + Math.random() * (b - a);
      const randInt = (a, b) => Math.floor(rand(a, b + 1));
      const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
      const deepClone = (o) => JSON.parse(JSON.stringify(o));

      // Random color utilities (HSL for pleasant palettes)
      const randColor = (alpha = true) => {
        const h = randInt(0, 359);
        const s = rand(55, 85);
        const l = rand(35, 70);
        const a = alpha ? rand(0.5, 1) : 1;
        return `hsla(${h} ${s}% ${l}% / ${a})`;
      };

      // Interpolate SVG path data endpoints near an axis for cleaner joins
      function snapToAxis(val, axisPos = 0.5, eps = 0.002) {
        return Math.abs(val - axisPos) < eps ? axisPos : val;
      }

      /**********************
       * Genotype schema
       * - Canvas is normalized to [0,1] in both axes for portability.
       * - Layers have even symmetry count (2,4,6,8...). Symmetry axes pass through center.
       * - Primitives: circle, rect, ellipse, line, polygon, polyline, path, group(recursive)
       **********************/

      function randomTransform() {
        return {
          rotate: rand(-180, 180),
          scaleX: rand(0.2, 1.8),
          scaleY: rand(0.2, 1.8),
          translateX: rand(-0.25, 0.25),
          translateY: rand(-0.25, 0.25),
          skewX: rand(-20, 20),
          skewY: rand(-20, 20),
        };
      }

      function randomStroke() {
        return {
          stroke: Math.random() < 0.85 ? randColor(true) : "none",
          strokeWidth: rand(0.002, 0.03),
          strokeOpacity: rand(0.4, 1),
          strokeLinecap: choice(["butt", "round", "square"]),
          strokeLinejoin: choice(["miter", "round", "bevel"]),
          strokeDasharray:
            Math.random() < 0.25
              ? `${rand(0.01, 0.1)} ${rand(0.01, 0.1)}`
              : null,
        };
      }

      function randomFill() {
        return {
          fill: Math.random() < 0.9 ? randColor(true) : "none",
          fillOpacity: rand(0.35, 1),
        };
      }

      function randomPrimitive(depth = 0) {
        const t = choice([
          "circle",
          "rect",
          "ellipse",
          "line",
          "polygon",
          "polyline",
          "path",
          ...(depth < 1 ? ["group"] : []),
        ]);
        const common = {
          type: t,
          opacity: rand(0.5, 1),
          transform: randomTransform(),
          ...randomStroke(),
          ...randomFill(),
        };

        switch (t) {
          case "circle":
            return {
              ...common,
              cx: rand(0, 1),
              cy: rand(0, 1),
              r: rand(0.03, 0.45),
            };
          case "rect":
            return {
              ...common,
              x: rand(0, 1),
              y: rand(0, 1),
              width: rand(0.05, 0.9),
              height: rand(0.05, 0.9),
              rx: Math.random() < 0.6 ? rand(0, 0.2) : 0,
              ry: Math.random() < 0.6 ? rand(0, 0.2) : 0,
            };
          case "ellipse":
            return {
              ...common,
              cx: rand(0, 1),
              cy: rand(0, 1),
              rx: rand(0.03, 0.45),
              ry: rand(0.03, 0.45),
            };
          case "line":
            return {
              ...common,
              x1: rand(0, 1),
              y1: rand(0, 1),
              x2: rand(0, 1),
              y2: rand(0, 1),
            };
          case "polygon":
            return {
              ...common,
              points: Array.from({ length: randInt(3, 9) }, (_) => [
                rand(0, 1),
                rand(0, 1),
              ]),
            };
          case "polyline":
            return {
              ...common,
              points: Array.from({ length: randInt(2, 12) }, (_) => [
                rand(0, 1),
                rand(0, 1),
              ]),
            };
          case "path": {
            // Build a small path with M + (C|Q|L) segments
            const segs = [];
            let x = rand(0, 1),
              y = rand(0, 1);
            segs.push(["M", x, y]);
            const n = randInt(1, 5);
            for (let i = 0; i < n; i++) {
              const type = choice(["L", "Q", "C"]);
              if (type === "L") {
                x = rand(0, 1);
                y = rand(0, 1);
                segs.push(["L", x, y]);
              } else if (type === "Q") {
                const cx = rand(0, 1),
                  cy = rand(0, 1);
                x = rand(0, 1);
                y = rand(0, 1);
                segs.push(["Q", cx, cy, x, y]);
              } else {
                const c1x = rand(0, 1),
                  c1y = rand(0, 1);
                const c2x = rand(0, 1),
                  c2y = rand(0, 1);
                x = rand(0, 1);
                y = rand(0, 1);
                segs.push(["C", c1x, c1y, c2x, c2y, x, y]);
              }
            }
            if (Math.random() < 0.5) segs.push(["Z"]);
            return { ...common, segments: segs };
          }
          case "group":
            return {
              ...common,
              children: Array.from({ length: randInt(2, 5) }, (_) =>
                randomPrimitive(depth + 1),
              ),
            };
        }
      }

      function randomLayer() {
        const sym = 2 * randInt(1, 4); // 2,4,6,8
        return {
          symmetry: sym,
          symmetryMode: choice(["radial", "axis"]), // radial: mirrored slices; axis: multiaxial mirrors
          primitives: Array.from({ length: randInt(2, 7) }, (_) =>
            randomPrimitive(0),
          ),
          opacity: rand(0.5, 1),
        };
      }

      function randomGenotype() {
        return {
          version: 1,
          width: 1024,
          height: 1024,
          background: Math.random() < 0.5 ? "transparent" : randColor(false),
          layers: Array.from({ length: randInt(1, 3) }, (_) => randomLayer()),
        };
      }

      /**********************
       * SVG Builder helpers
       **********************/

      function attrs(obj) {
        return Object.entries(obj)
          .filter(([_, v]) => v !== undefined && v !== null)
          .map(([k, v]) => `${k}="${String(v).replace(/"/g, "&quot;")}"`)
          .join(" ");
      }

      function transformStr(t) {
        if (!t) return "";
        const parts = [];
        if (t.translateX || t.translateY)
          parts.push(`translate(${t.translateX || 0} ${t.translateY || 0})`);
        if (t.rotate) parts.push(`rotate(${t.rotate} 0.5 0.5)`);
        if (t.skewX) parts.push(`skewX(${t.skewX})`);
        if (t.skewY) parts.push(`skewY(${t.skewY})`);
        if (t.scaleX || t.scaleY)
          parts.push(`scale(${t.scaleX || 1} ${t.scaleY || 1})`);
        return parts.join(" ");
      }

      function pointsToStr(points) {
        return points.map((p) => p.join(",")).join(" ");
      }

      function segmentsToPath(segments) {
        // Robust converter: ensure paths always start with a moveto ('M')
        if (!segments || segments.length === 0) return "";
        // shallow copy so we don't mutate original
        const segs = segments.map((s) => s.slice());
        // if first segment is not 'M', insert a moveto using the first numeric pair we can find
        if (segs[0][0] !== "M") {
          if (segs[0].length >= 3) {
            const nums = segs[0].slice(1);
            const x = nums[nums.length - 2] ?? 0.5;
            const y = nums[nums.length - 1] ?? 0.5;
            segs.unshift(["M", x, y]);
          } else {
            segs.unshift(["M", 0.5, 0.5]);
          }
        }
        return segs
          .map((seg) => seg[0] + " " + seg.slice(1).join(" "))
          .join(" ");
      }

      function applyAxisSnappingToSegments(segments, axis = "vertical") {
        const center = 0.5;
        const out = [];
        for (const seg of segments) {
          const t = seg[0];
          const nums = seg.slice(1);
          const snapped = nums.slice();
          if (axis === "vertical") {
            for (let i = 0; i < snapped.length; i += 2) {
              snapped[i] = snapToAxis(snapped[i], center);
            }
          } else {
            for (let i = 1; i < snapped.length; i += 2) {
              snapped[i] = snapToAxis(snapped[i], center);
            }
          }
          out.push([t, ...snapped]);
        }
        return out;
      }

      // ClipPath wedge for radial symmetry slice i of n
      function radialClipPath(id, i, n) {
        const cx = 0.5,
          cy = 0.5;
        const theta0 = (i * 2 * Math.PI) / n;
        const theta1 = ((i + 1) * 2 * Math.PI) / n;
        const r = 2; // cover box
        const x0 = cx + r * Math.cos(theta0),
          y0 = cy + r * Math.sin(theta0);
        const x1 = cx + r * Math.cos(theta1),
          y1 = cy + r * Math.sin(theta1);
        return `<clipPath id="${id}"><polygon points="${cx},${cy} ${x0},${y0} ${x1},${y1}" /></clipPath>`;
      }

      function primitiveToSvg(prim) {
        const base = {
          opacity: prim.opacity,
          fill: prim.fill,
          "fill-opacity": prim.fillOpacity,
          stroke: prim.stroke,
          "stroke-width": prim.strokeWidth,
          "stroke-opacity": prim.strokeOpacity,
          "stroke-linecap": prim.strokeLinecap,
          "stroke-linejoin": prim.strokeLinejoin,
          "stroke-dasharray": prim.strokeDasharray,
          transform: transformStr(prim.transform),
          vectorEffect: "non-scaling-stroke",
        };
        switch (prim.type) {
          case "circle":
            return `<circle ${attrs({ ...base, cx: prim.cx, cy: prim.cy, r: prim.r })} />`;
          case "rect":
            return `<rect ${attrs({ ...base, x: prim.x, y: prim.y, width: prim.width, height: prim.height, rx: prim.rx, ry: prim.ry })} />`;
          case "ellipse":
            return `<ellipse ${attrs({ ...base, cx: prim.cx, cy: prim.cy, rx: prim.rx, ry: prim.ry })} />`;
          case "line":
            return `<line ${attrs({ ...base, x1: prim.x1, y1: prim.y1, x2: prim.x2, y2: prim.y2 })} />`;
          case "polygon":
            return `<polygon ${attrs({ ...base, points: pointsToStr(prim.points) })} />`;
          case "polyline":
            return `<polyline ${attrs({ ...base, points: pointsToStr(prim.points) })} />`;
          case "path": {
            const d = segmentsToPath(prim.segments);
            return `<path ${attrs({ ...base, d })} />`;
          }
          case "group": {
            const children = prim.children.map(primitiveToSvg).join("");
            return `<g ${attrs({ ...base })}>${children}</g>`;
          }
        }
      }

      // Render a single layer with symmetry
      function renderLayer(layer, defsBuf) {
        const n = Math.max(2, layer.symmetry - (layer.symmetry % 2));
        const mode = layer.symmetryMode || "radial";
        const layerContent = layer.primitives.map(primitiveToSvg).join("");
        if (n === 2 && mode === "axis") {
          // Simple mirror across vertical & horizontal axis (2 axes)
          const contentV = layer.primitives
            .map((p) => {
              if (p.type === "path") {
                const mirrored = deepClone(p);
                const segs = mirrored.segments.map((seg) => {
                  const [t, ...nums] = seg;
                  for (let i = 0; i < nums.length; i += 2)
                    nums[i] = 1 - nums[i];
                  return [t, ...nums];
                });
                mirrored.segments = applyAxisSnappingToSegments(
                  segs,
                  "vertical",
                );
                return primitiveToSvg(mirrored);
              } else if (p.points) {
                const q = deepClone(p);
                q.points = q.points.map(([x, y]) => [1 - x, y]);
                return primitiveToSvg(q);
              } else {
                const q = deepClone(p);
                if ("cx" in q) q.cx = 1 - q.cx;
                if ("x" in q) q.x = 1 - (q.x + q.width);
                if ("x1" in q) {
                  q.x1 = 1 - q.x1;
                  q.x2 = 1 - q.x2;
                }
                return primitiveToSvg(q);
              }
            })
            .join("");
          const contentH = layer.primitives
            .map((p) => {
              if (p.type === "path") {
                const mirrored = deepClone(p);
                const segs = mirrored.segments.map((seg) => {
                  const [t, ...nums] = seg;
                  for (let i = 1; i < nums.length; i += 2)
                    nums[i] = 1 - nums[i];
                  return [t, ...nums];
                });
                mirrored.segments = applyAxisSnappingToSegments(
                  segs,
                  "horizontal",
                );
                return primitiveToSvg(mirrored);
              } else if (p.points) {
                const q = deepClone(p);
                q.points = q.points.map(([x, y]) => [x, 1 - y]);
                return primitiveToSvg(q);
              } else {
                const q = deepClone(p);
                if ("cy" in q) q.cy = 1 - q.cy;
                if ("y" in q) q.y = 1 - (q.y + q.height);
                if ("y1" in q) {
                  q.y1 = 1 - q.y1;
                  q.y2 = 1 - q.y2;
                }
                return primitiveToSvg(q);
              }
            })
            .join("");
          const base = `<g opacity="${layer.opacity ?? 1}">${layerContent}</g>`;
          const v = `<g opacity="${layer.opacity ?? 1}">${contentV}</g>`;
          const h = `<g opacity="${layer.opacity ?? 1}">${contentH}</g>`;
          const hv = `<g opacity="${layer.opacity ?? 1}">${contentV}${contentH}</g>`;
          return base + v + h + hv;
        }

        // Radial mirror with clipping per slice + snapping near axes to join
        // Create clip paths for each wedge
        const idBase = `clip_${Math.random().toString(36).slice(2)}`;
        for (let i = 0; i < n; i++)
          defsBuf.push(radialClipPath(`${idBase}_${i}`, i, n));

        const out = [];
        for (let i = 0; i < n; i++) {
          const angle = (360 / n) * i;
          // For paths, snap near axis to avoid seams
          const content = layer.primitives
            .map((p) => {
              if (p.type === "path") {
                const q = deepClone(p);
                // simple snap near both center axes prior to rotation
                q.segments = applyAxisSnappingToSegments(
                  q.segments,
                  "vertical",
                );
                q.segments = applyAxisSnappingToSegments(
                  q.segments,
                  "horizontal",
                );
                return primitiveToSvg(q);
              }
              if (p.points) {
                const q = deepClone(p);
                q.points = q.points.map(([x, y]) => [
                  snapToAxis(x),
                  snapToAxis(y),
                ]);
                return primitiveToSvg(q);
              }
              return primitiveToSvg(p);
            })
            .join("");
          out.push(
            `<g clip-path="url(#${idBase}_${i})" transform="rotate(${angle} 0.5 0.5)"><g opacity="${layer.opacity ?? 1}">${content}</g></g>`,
          );
        }
        return out.join("");
      }

      function genotypeToSvg(gen) {
        const w = gen.width || 1024,
          h = gen.height || 1024;
        const defs = [];
        const layers = gen.layers.map((l) => renderLayer(l, defs)).join("");
        const bg =
          gen.background && gen.background !== "transparent"
            ? `<rect x="0" y="0" width="1" height="1" fill="${gen.background}"/>`
            : "";
        const svg =
          `<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1" width="${w}" height="${h}" preserveAspectRatio="xMidYMid meet">` +
          `<defs>${defs.join("")}</defs>` +
          `${bg}` +
          layers +
          `</svg>`;
        return svg;
      }

      /**********************
       * Mutation engine
       **********************/

      function mutateNumber(x, P, range = [0, 1], scale = 0.2) {
        if (Math.random() > P) return x;
        const wiggle = (Math.random() * 2 - 1) * scale * (range[1] - range[0]);
        const v = clamp(x + wiggle, range[0], range[1]);
        return v;
      }

      function mutateColor(c, P) {
        if (Math.random() > P) return c;
        // crude HSL mutate for hsla(h s% l% / a)
        const m = c.match(
          /hsla?\((\d+)\s+(\d+)%\s+(\d+)%\s*\/?\s*(\d*\.?\d+)?\)/,
        );
        if (!m) return randColor(true);
        let [_, h, s, l, a] = m;
        h = +h;
        s = +s;
        l = +l;
        a = a == null ? 1 : +a;
        h = (h + randInt(-20, 20) + 360) % 360;
        s = clamp(s + randInt(-10, 10), 10, 95);
        l = clamp(l + randInt(-10, 10), 5, 95);
        a = clamp(a + rand(-0.2, 0.2), 0.15, 1);
        return `hsla(${h} ${s}% ${l}% / ${a})`;
      }

      function maybe(prob) {
        return Math.random() < prob;
      }

      function mutateTransform(t, P) {
        const q = { ...t };
        if (maybe(P)) q.rotate += rand(-25, 25);
        if (maybe(P)) q.scaleX = clamp(q.scaleX + rand(-0.3, 0.3), 0.05, 2.5);
        if (maybe(P)) q.scaleY = clamp(q.scaleY + rand(-0.3, 0.3), 0.05, 2.5);
        if (maybe(P))
          q.translateX = clamp(q.translateX + rand(-0.1, 0.1), -0.5, 0.5);
        if (maybe(P))
          q.translateY = clamp(q.translateY + rand(-0.1, 0.1), -0.5, 0.5);
        if (maybe(P)) q.skewX = clamp(q.skewX + rand(-5, 5), -45, 45);
        if (maybe(P)) q.skewY = clamp(q.skewY + rand(-5, 5), -45, 45);
        return q;
      }

      function mutateStrokeFill(p, P) {
        const q = { ...p };
        if (maybe(P))
          q.fill =
            p.fill === "none" && Math.random() < 0.7
              ? randColor(true)
              : mutateColor(p.fill, P);
        if (maybe(P))
          q.fillOpacity = clamp((q.fillOpacity ?? 1) + rand(-0.2, 0.2), 0, 1);
        if (maybe(P))
          q.stroke =
            p.stroke === "none" && Math.random() < 0.7
              ? randColor(true)
              : mutateColor(p.stroke, P);
        if (maybe(P))
          q.strokeWidth = clamp(
            (q.strokeWidth ?? 0.01) * rand(0.5, 1.6),
            0.001,
            0.08,
          );
        if (maybe(P))
          q.strokeOpacity = clamp(
            (q.strokeOpacity ?? 1) + rand(-0.2, 0.2),
            0,
            1,
          );
        if (maybe(P)) q.strokeLinecap = choice(["butt", "round", "square"]);
        if (maybe(P)) q.strokeLinejoin = choice(["miter", "round", "bevel"]);
        if (maybe(P))
          q.strokeDasharray =
            Math.random() < 0.5
              ? `${rand(0.005, 0.12)} ${rand(0.005, 0.12)}`
              : null;
        if (maybe(P))
          q.opacity = clamp((q.opacity ?? 1) + rand(-0.2, 0.2), 0.1, 1);
        q.transform = mutateTransform(q.transform || randomTransform(), P);
        return q;
      }

      function mutatePoints(points, P) {
        const out = points.map(([x, y]) => [
          mutateNumber(x, P, [0, 1], 0.15),
          mutateNumber(y, P, [0, 1], 0.15),
        ]);
        if (maybe(P * 0.6) && points.length > 2)
          out.splice(randInt(0, out.length - 1), 1); // remove a node
        if (maybe(P * 0.6) && points.length < 48)
          out.splice(randInt(0, out.length), 0, [rand(0, 1), rand(0, 1)]); // add a node
        return out;
      }

      function mutateSegments(segments, p) {
        let newSegs = segments.map((seg) => seg.slice());

        for (let i = 0; i < newSegs.length; i++) {
          if (i === 0) continue; // never mutate/remove the initial M
          if (Math.random() < p) {
            let seg = newSegs[i];
            for (let j = 1; j < seg.length; j++) {
              seg[j] += (Math.random() - 0.5) * 0.1;
              seg[j] = Math.max(0, Math.min(1, seg[j]));
            }
          }
        }

        if (Math.random() < p && newSegs.length > 1) {
          newSegs.splice(
            1 + Math.floor(Math.random() * (newSegs.length - 1)),
            1,
          );
        }

        if (Math.random() < p) {
          const x = Math.random(),
            y = Math.random();
          newSegs.push(["L", x, y]);
        }

        return newSegs;
      }

      function mutatePrimitive(p, P, depth = 0) {
        let q = mutateStrokeFill(p, P);
        switch (p.type) {
          case "circle":
            q.cx = mutateNumber(p.cx, P, [0, 1]);
            q.cy = mutateNumber(p.cy, P, [0, 1]);
            q.r = mutateNumber(p.r, P, [0.005, 0.9]);
            break;
          case "rect":
            q.x = mutateNumber(p.x, P, [0, 1]);
            q.y = mutateNumber(p.y, P, [0, 1]);
            q.width = mutateNumber(p.width, P, [0.01, 1]);
            q.height = mutateNumber(p.height, P, [0.01, 1]);
            q.rx = mutateNumber(p.rx || 0, P, [0, 0.5]);
            q.ry = mutateNumber(p.ry || 0, P, [0, 0.5]);
            break;
          case "ellipse":
            q.cx = mutateNumber(p.cx, P, [0, 1]);
            q.cy = mutateNumber(p.cy, P, [0, 1]);
            q.rx = mutateNumber(p.rx, P, [0.005, 0.9]);
            q.ry = mutateNumber(p.ry, P, [0.005, 0.9]);
            break;
          case "line":
            q.x1 = mutateNumber(p.x1, P, [0, 1]);
            q.y1 = mutateNumber(p.y1, P, [0, 1]);
            q.x2 = mutateNumber(p.x2, P, [0, 1]);
            q.y2 = mutateNumber(p.y2, P, [0, 1]);
            break;
          case "polygon":
          case "polyline":
            q.points = mutatePoints(p.points, P);
            break;
          case "path":
            q.segments = mutateSegments(p.segments, P);
            break;
          case "group":
            q.children = p.children.map((ch) =>
              mutatePrimitive(ch, P, depth + 1),
            );
            if (maybe(P * 0.5) && q.children.length > 1)
              q.children.splice(randInt(0, q.children.length - 1), 1);
            if (maybe(P * 0.5) && q.children.length < 12)
              q.children.splice(
                randInt(0, q.children.length),
                0,
                randomPrimitive(depth + 1),
              );
            break;
        }
        // occasional type flip (recoding genes)
        if (maybe(P * 0.15) && depth === 0) {
          const newP = randomPrimitive(0);
          // inherit style-ish genes
          newP.fill = q.fill;
          newP.stroke = q.stroke;
          newP.strokeWidth = q.strokeWidth;
          newP.opacity = q.opacity;
          newP.transform = q.transform;
          q = newP;
        }
        return q;
      }

      function mutateLayer(layer, P) {
        const out = deepClone(layer);
        if (maybe(P * 0.4))
          out.symmetry =
            2 * clamp(Math.round((out.symmetry + randInt(-2, 2)) / 2), 1, 6);
        if (maybe(P * 0.25)) out.symmetryMode = choice(["radial", "axis"]);
        if (maybe(P * 0.3))
          out.opacity = clamp((out.opacity ?? 1) + rand(-0.2, 0.2), 0.1, 1);
        out.primitives = out.primitives.map((p) => mutatePrimitive(p, P));
        if (maybe(P * 0.6) && out.primitives.length > 1)
          out.primitives.splice(randInt(0, out.primitives.length - 1), 1);
        if (maybe(P * 0.6) && out.primitives.length < 20)
          out.primitives.splice(
            randInt(0, out.primitives.length),
            0,
            randomPrimitive(),
          );
        return out;
      }

      function mutateGenotype(gen, P) {
        const g = deepClone(gen);
        if (maybe(P * 0.2))
          g.background =
            Math.random() < 0.5
              ? "transparent"
              : mutateColor(g.background || randColor(false), P);
        g.layers = g.layers.map((l) => mutateLayer(l, P));
        if (maybe(P * 0.4) && g.layers.length > 1)
          g.layers.splice(randInt(0, g.layers.length - 1), 1);
        if (maybe(P * 0.4) && g.layers.length < 10)
          g.layers.splice(randInt(0, g.layers.length), 0, randomLayer());
        return g;
      }

      /**********************
       * UI & Evolution grid
       **********************/

      const gridEl = document.getElementById("grid");
      let parentGen = randomGenotype();

      const mutationPlan = [0.1, 0.1, 0.1, 0.3, 0, 0.3, 0.5, 0.5, 0.5]; // center has 0

      function svgStringToElement(svgStr) {
        const div = document.createElement("div");
        div.innerHTML = svgStr.trim();
        return div;
      }

      function renderGrid() {
        gridEl.innerHTML = "";
        const gens = mutationPlan.map((P, idx) =>
          P === 0 ? parentGen : mutateGenotype(parentGen, P),
        );
        gens.forEach((gen, idx) => {
          const cell = document.createElement("div");
          cell.className = "cell" + (idx === 4 ? " center" : "");
          const svg = genotypeToSvg(gen);
          const el = svgStringToElement(svg);
          cell.appendChild(el);
          const badge = document.createElement("div");
          badge.className = "badge";
          if (idx === 4) {
            badge.textContent = "Parent";
          } else {
            const P = mutationPlan[idx];
            badge.textContent = `P=${P.toFixed(1)}`;
            badge.style.color =
              P === 0.1
                ? "var(--mut-1)"
                : P === 0.3
                  ? "var(--mut-2)"
                  : "var(--mut-3)";
            badge.style.borderColor =
              P === 0.1 ? "#1e3a8a" : P === 0.3 ? "#78350f" : "#7f1d1d";
          }
          cell.appendChild(badge);
          cell.addEventListener("click", () => {
            if (idx !== 4) {
              parentGen = gen; // adopt child as new parent
              renderGrid();
            }
          });
          gridEl.appendChild(cell);
        });
      }

      /**********************
       * Export / Import
       **********************/

      function download(filename, data, type) {
        const blob = new Blob([data], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(url);
          a.remove();
        }, 0);
      }

      document.getElementById("saveSvg").addEventListener("click", () => {
        const svg = genotypeToSvg(parentGen);
        download("evo-art.svg", svg, "image/svg+xml");
      });

      document.getElementById("savePng").addEventListener("click", async () => {
        const svg = genotypeToSvg(parentGen);
        const img = new Image();
        const svgBlob = new Blob([svg], { type: "image/svg+xml" });
        const url = URL.createObjectURL(svgBlob);
        await new Promise((res) => {
          img.onload = res;
          img.src = url;
        });
        const canvas = document.createElement("canvas");
        const w = parentGen.width || 1024,
          h = parentGen.height || 1024;
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h);
        canvas.toBlob((blob) => {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "evo-art.png";
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            a.remove();
          }, 0);
        }, "image/png");
        URL.revokeObjectURL(url);
      });

      document.getElementById("randomize").addEventListener("click", () => {
        parentGen = randomGenotype();
        renderGrid();
      });

      document.getElementById("exportGen").addEventListener("click", () => {
        download(
          "genotype.json",
          JSON.stringify(parentGen, null, 2),
          "application/json",
        );
      });

      document.getElementById("importGen").addEventListener("click", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "application/json";
        input.onchange = async () => {
          const file = input.files[0];
          if (!file) return;
          const text = await file.text();
          try {
            parentGen = JSON.parse(text);
            renderGrid();
          } catch (e) {
            alert("Invalid JSON");
          }
        };
        input.click();
      });

      // Initial render
      renderGrid(1);
    </script>
  </body>
</html>
