<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Evolutionary SVG — Fixed Prototype v3 (Clipping + Joining)</title>
    <style>
      :root {
        --bg: #0b0c10;
        --cell: #0f1724;
        --fg: #e6eef6;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family:
          Inter,
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto;
      }
      header {
        padding: 10px 14px;
        display: flex;
        gap: 8px;
        align-items: center;
        background: rgba(2, 6, 23, 0.7);
        position: sticky;
        top: 0;
      }
      .grid {
        width: min(1100px, 100%);
        margin: 12px auto;
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
      }
      .cell {
        background: var(--cell);
        border-radius: 12px;
        overflow: hidden;
        aspect-ratio: 1/1;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .cell svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .badge {
        position: absolute;
        left: 10px;
        top: 10px;
        padding: 6px 8px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.35);
        font-size: 13px;
      }
      .toolbar {
        margin-left: auto;
        display: flex;
        gap: 8px;
      }
      button {
        background: #06202b;
        color: var(--fg);
        border: 1px solid rgba(255, 255, 255, 0.03);
        padding: 8px 10px;
        border-radius: 10px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <header>
      <div style="font-weight: 600">Evolutionary SVG — Fixed v3</div>
      <div class="toolbar">
        <button id="saveSvg">Save SVG</button>
        <button id="savePng">Save PNG</button>
        <button id="randomize">Random Parent</button>
      </div>
    </header>

    <main>
      <div id="grid" class="grid"></div>
    </main>

    <script>
      const ns = "http://www.w3.org/2000/svg";
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const rand = (a = 0, b = 1) => a + Math.random() * (b - a);
      const randInt = (a, b) => Math.floor(rand(a, b + 1));
      const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];
      const deep = (o) => JSON.parse(JSON.stringify(o));
      function randColor() {
        return `hsl(${randInt(0, 359)} ${Math.round(rand(45, 85))}% ${Math.round(rand(25, 70))}%)`;
      }

      /* Genotype randoms */
      function randomShape() {
        const types = ["circle", "rect", "path"];
        const t = choice(types);
        const hasFill = Math.random() < 0.8;
        const hasStroke = Math.random() < 0.9;
        if (t === "circle")
          return {
            type: "circle",
            x: rand(0.25, 0.75),
            y: rand(0.1, 0.9),
            r: rand(0.02, 0.14),
            fillIdx: hasFill ? 0 : -1,
            strokeIdx: hasStroke ? 0 : -1,
          };
        if (t === "rect")
          return {
            type: "rect",
            x: rand(0.2, 0.8),
            y: rand(0.1, 0.9),
            w: rand(0.03, 0.4),
            h: rand(0.03, 0.4),
            rx: rand(0, 0.12),
            fillIdx: hasFill ? 0 : -1,
            strokeIdx: hasStroke ? 0 : -1,
          };
        const segs = [["M", rand(0.15, 0.85), rand(0.05, 0.95)]];
        const n = randInt(1, 5);
        for (let i = 0; i < n; i++) {
          if (Math.random() < 0.6)
            segs.push(["L", rand(0.05, 0.95), rand(0.05, 0.95)]);
          else
            segs.push([
              "C",
              rand(0.05, 0.95),
              rand(0.05, 0.95),
              rand(0.05, 0.95),
              rand(0.05, 0.95),
              rand(0.05, 0.95),
              rand(0.05, 0.95),
            ]);
        }
        if (Math.random() < 0.35) segs.push(["Z"]);
        return {
          type: "path",
          segments: segs,
          fillIdx: hasFill ? 0 : -1,
          strokeIdx: hasStroke ? 0 : -1,
        };
      }
      function randomLayer(symOptions) {
        const symmetry = symOptions ? choice(symOptions) : 2 * randInt(2, 6);
        return {
          opacity: rand(0.6, 1),
          blend: "normal",
          symmetry,
          shapes: Array.from({ length: randInt(1, 10) }, () => randomShape()),
        };
      }
      function randomGenotype() {
        const symmetryValues = [1, 2, 4, 6, 8];
        const palette = Array.from({ length: randInt(3, 16) }, () =>
          randColor(),
        );
        const strokes = Array.from({ length: randInt(2, 4) }, () =>
          rand(0.2, 2),
        );
        const layers = Array.from({ length: randInt(1, 6) }, () =>
          randomLayer(symmetryValues),
        );
        return {
          symmetryValues,
          globals: {
            palette,
            strokes,
            background: Math.random() < 0.4 ? "transparent" : randColor(),
          },
          layers,
        };
      }

      /* Geometry */
      function polarToXY(r, angle) {
        const cx = 0.5,
          cy = 0.5;
        return [cx + r * Math.cos(angle), cy + r * Math.sin(angle)];
      }
      function mapPointInSectorToXY(
        xLocal,
        yLocal,
        sectorIndex,
        symmetryCount,
        mirrored = false,
      ) {
        const sectorSpan = (2 * Math.PI) / symmetryCount;
        const angleOffset = (xLocal - 0.5) * sectorSpan;
        const angleRel = mirrored ? -angleOffset : angleOffset;
        const maxR = Math.SQRT2 * 0.5;
        const r = clamp(yLocal, 0, 1) * maxR;
        const angle = angleRel + sectorIndex * sectorSpan;
        return polarToXY(r, angle);
      }
      function el(tag, attrs = {}) {
        const e = document.createElementNS(ns, tag);
        for (const k in attrs)
          if (attrs[k] !== undefined) e.setAttribute(k, String(attrs[k]));
        return e;
      }

      /* Clipping and merging utilities */
      function rotatePoint(p, angle) {
        const cx = 0.5,
          cy = 0.5;
        const s = Math.sin(angle),
          c = Math.cos(angle);
        const x = p[0] - cx,
          y = p[1] - cy;
        return [cx + x * c - y * s, cy + x * s + y * c];
      }
      function isInside(p, cp1, cp2) {
        return (
          (cp2[0] - cp1[0]) * (p[1] - cp1[1]) >=
          (cp2[1] - cp1[1]) * (p[0] - cp1[0])
        );
      }
      function intersection(s, e, cp1, cp2) {
        const dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
        const dp = [s[0] - e[0], s[1] - e[1]];
        const n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0];
        const n2 = s[0] * e[1] - s[1] * e[0];
        const denom = dc[0] * dp[1] - dc[1] * dp[0];
        if (Math.abs(denom) < 1e-9)
          return [(s[0] + e[0]) / 2, (s[1] + e[1]) / 2];
        const x = (n1 * dp[0] - n2 * dc[0]) / denom;
        const y = (n1 * dp[1] - n2 * dc[1]) / denom;
        return [x, y];
      }
      function clipPolygon(subjectPolygon, clipPolygon) {
        let outputList = subjectPolygon.slice();
        for (let i = 0; i < clipPolygon.length; i++) {
          const cp1 = clipPolygon[i],
            cp2 = clipPolygon[(i + 1) % clipPolygon.length];
          const inputList = outputList.slice();
          outputList = [];
          if (inputList.length === 0) break;
          let S = inputList[inputList.length - 1];
          for (let j = 0; j < inputList.length; j++) {
            const E = inputList[j];
            if (isInside(E, cp1, cp2)) {
              if (!isInside(S, cp1, cp2))
                outputList.push(intersection(S, E, cp1, cp2));
              outputList.push(E);
            } else if (isInside(S, cp1, cp2)) {
              outputList.push(intersection(S, E, cp1, cp2));
            }
            S = E;
          }
        }
        return outputList;
      }
      function mergeNearbyVerticesAcrossClones(clones, eps) {
        const n = clones.length;
        for (let i = 0; i < n; i++) {
          const a = clones[i],
            b = clones[(i + 1) % n];
          for (let ia = 0; ia < a.length; ia++) {
            for (let ib = 0; ib < b.length; ib++) {
              const dx = a[ia][0] - b[ib][0],
                dy = a[ia][1] - b[ib][1];
              if (dx * dx + dy * dy < eps * eps) {
                const mx = (a[ia][0] + b[ib][0]) / 2,
                  my = (a[ia][1] + b[ib][1]) / 2;
                a[ia][0] = mx;
                a[ia][1] = my;
                b[ib][0] = mx;
                b[ib][1] = my;
              }
            }
          }
        }
      }
      function stitchClonesToPath(clones) {
        const pts = [];
        for (const poly of clones) for (const p of poly) pts.push(p);
        if (pts.length === 0) return "";
        let d = `M ${pts[0][0]} ${pts[0][1]}`;
        for (let i = 1; i < pts.length; i++)
          d += ` L ${pts[i][0]} ${pts[i][1]}`;
        d += " Z";
        return d;
      }

      /* Approximate shape to polygon in global coords for sector 0 */
      function approxShapeToPolygon(shape, sym) {
        const pts = [];
        if (shape.type === "circle") {
          const samples = 32;
          for (let i = 0; i < samples; i++) {
            const a = (i / samples) * 2 * Math.PI;
            const lx = shape.x + Math.cos(a) * shape.r;
            const ly = shape.y + Math.sin(a) * shape.r;
            pts.push(mapPointInSectorToXY(lx, ly, 0, sym, false));
          }
          return pts;
        }
        if (shape.type === "rect") {
          const corners = [
            [shape.x, shape.y],
            [shape.x + shape.w, shape.y],
            [shape.x + shape.w, shape.y + shape.h],
            [shape.x, shape.y + shape.h],
          ];
          for (const c of corners)
            pts.push(mapPointInSectorToXY(c[0], c[1], 0, sym, false));
          return pts;
        }
        if (shape.type === "path") {
          for (const seg of shape.segments) {
            const cmd = seg[0];
            if (cmd === "M" || cmd === "L")
              pts.push(mapPointInSectorToXY(seg[1], seg[2], 0, sym, false));
            else if (cmd === "C") {
              const [, x1, y1, x2, y2, x3, y3] = seg;
              const p0 = pts.length
                ? pts[pts.length - 1]
                : mapPointInSectorToXY(
                    shape.segments[0][1],
                    shape.segments[0][2],
                    0,
                    sym,
                    false,
                  );
              const p1 = mapPointInSectorToXY(x1, y1, 0, sym, false);
              const p2 = mapPointInSectorToXY(x2, y2, 0, sym, false);
              const p3 = mapPointInSectorToXY(x3, y3, 0, sym, false);
              const steps = 12;
              for (let t = 1; t <= steps; t++) {
                const u = t / steps;
                const x =
                  Math.pow(1 - u, 3) * p0[0] +
                  3 * Math.pow(1 - u, 2) * u * p1[0] +
                  3 * (1 - u) * Math.pow(u, 2) * p2[0] +
                  Math.pow(u, 3) * p3[0];
                const y =
                  Math.pow(1 - u, 3) * p0[1] +
                  3 * Math.pow(1 - u, 2) * u * p1[1] +
                  3 * (1 - u) * Math.pow(u, 2) * p2[1] +
                  Math.pow(u, 3) * p3[1];
                pts.push([x, y]);
              }
            }
          }
          return pts;
        }
        return pts;
      }

      /* Convert shape into a single merged path across all sectors: clip base polygon to wedge, rotate clones, merge, stitch */
      function shapeToMergedPath(shape, genotype, sym) {
        const basePoly = approxShapeToPolygon(shape, sym);
        if (!basePoly || basePoly.length === 0) return null;
        const n = sym;
        const i0 = 0;
        const theta0 = (i0 - 0.5) * ((2 * Math.PI) / n),
          theta1 = (i0 + 0.5) * ((2 * Math.PI) / n);
        const r = Math.SQRT2;
        const cx = 0.5,
          cy = 0.5;
        const x0 = cx + r * Math.cos(theta0),
          y0 = cy + r * Math.sin(theta0);
        const x1 = cx + r * Math.cos(theta1),
          y1 = cy + r * Math.sin(theta1);
        const wedge = [
          [cx, cy],
          [x0, y0],
          [x1, y1],
        ];
        const clipped0 = clipPolygon(basePoly, wedge);
        if (!clipped0 || clipped0.length === 0) return null;
        const clones = [];
        for (let si = 0; si < n; si++) {
          const angle = si * ((2 * Math.PI) / n);
          clones.push(clipped0.map((p) => rotatePoint(p, angle)));
        }
        mergeNearbyVerticesAcrossClones(clones, 0.012);
        const d = stitchClonesToPath(clones);
        const path = el("path", { d });
        if (shape.fillIdx >= 0)
          path.setAttribute(
            "fill",
            genotype.globals.palette[
              shape.fillIdx % genotype.globals.palette.length
            ],
          );
        else path.setAttribute("fill", "none");
        if (shape.strokeIdx >= 0)
          path.setAttribute(
            "stroke",
            genotype.globals.palette[
              shape.strokeIdx % genotype.globals.palette.length
            ],
          );
        else path.setAttribute("stroke", "none");
        path.setAttribute(
          "stroke-width",
          genotype.globals.strokes[
            Math.abs(shape.strokeIdx || 0) % genotype.globals.strokes.length
          ],
        );
        path.setAttribute("vector-effect", "non-scaling-stroke");
        return path;
      }

      function renderLayerToGroup(layer, genotype, svgSize) {
        const g = el("g");
        g.setAttribute("opacity", layer.opacity ?? 1);
        const n =
          layer.symmetry ||
          (genotype.symmetryValues && genotype.symmetryValues[0]) ||
          6;
        for (const sh of layer.shapes) {
          const p = shapeToMergedPath(sh, genotype, n);
          if (p) g.appendChild(p);
        }
        return g;
      }

      function genotypeToSvgElement(genotype, size = 1024) {
        const svg = el("svg", {
          xmlns: ns,
          viewBox: "0 0 1 1",
          width: size,
          height: size,
          preserveAspectRatio: "xMidYMid meet",
        });
        if (
          genotype.globals &&
          genotype.globals.background &&
          genotype.globals.background !== "transparent"
        ) {
          svg.appendChild(
            el("rect", {
              x: 0,
              y: 0,
              width: 1,
              height: 1,
              fill: genotype.globals.background,
            }),
          );
        }
        for (const layer of genotype.layers) {
          svg.appendChild(renderLayerToGroup(layer, genotype, size));
        }
        return svg;
      }

      /* Mutation engine (structural + param) */
      function mutateGenotype(gen, P) {
        const g = deep(gen);
        if (Math.random() < P * 0.15) {
          if (Math.random() < 0.5) g.symmetryValues.push(2 * randInt(2, 6));
          else if (g.symmetryValues.length > 2)
            g.symmetryValues.splice(randInt(0, g.symmetryValues.length - 1), 1);
        }
        if (g.globals && g.globals.palette) {
          g.globals.palette = g.globals.palette.map((c) =>
            Math.random() < P ? randColor() : c,
          );
          if (Math.random() < P * 0.2) g.globals.palette.push(randColor());
          if (Math.random() < P * 0.1 && g.globals.palette.length > 2)
            g.globals.palette.splice(
              randInt(0, g.globals.palette.length - 1),
              1,
            );
        }
        if (Math.random() < P * 0.25 && g.layers.length > 1)
          g.layers.splice(randInt(0, g.layers.length - 1), 1);
        if (Math.random() < P * 0.3 && g.layers.length < 10)
          g.layers.splice(
            randInt(0, g.layers.length),
            0,
            randomLayer(g.symmetryValues),
          );
        for (const layer of g.layers) {
          if (Math.random() < P * 0.4)
            layer.opacity = clamp(
              (layer.opacity || 1) + rand(-0.3, 0.3),
              0.05,
              1,
            );
          if (Math.random() < P * 0.25)
            layer.symmetry = choice(g.symmetryValues);
          layer.shapes = layer.shapes.filter(() => Math.random() > P * 0.35);
          if (Math.random() < P * 0.35) layer.shapes.push(randomShape());
          for (const s of layer.shapes) {
            if (s.type === "circle") {
              if (Math.random() < P) s.x = clamp(s.x + rand(-0.2, 0.2), 0, 1);
              if (Math.random() < P) s.y = clamp(s.y + rand(-0.25, 0.25), 0, 1);
              if (Math.random() < P)
                s.r = clamp(s.r + rand(-0.05, 0.05), 0.005, 0.4);
              if (Math.random() < P * 0.5)
                s.fillIdx =
                  s.fillIdx < 0
                    ? Math.random() < 0.5
                      ? -1
                      : 0
                    : (s.fillIdx + randInt(-1, 1) + g.globals.palette.length) %
                      g.globals.palette.length;
              if (Math.random() < P * 0.5)
                s.strokeIdx =
                  s.strokeIdx < 0
                    ? Math.random() < 0.5
                      ? -1
                      : 0
                    : (s.strokeIdx +
                        randInt(-1, 1) +
                        g.globals.palette.length) %
                      g.globals.palette.length;
            }
            if (s.type === "rect") {
              if (Math.random() < P) s.x = clamp(s.x + rand(-0.2, 0.2), 0, 1);
              if (Math.random() < P) s.y = clamp(s.y + rand(-0.25, 0.25), 0, 1);
              if (Math.random() < P)
                s.w = clamp(s.w + rand(-0.2, 0.2), 0.01, 1);
              if (Math.random() < P)
                s.h = clamp(s.h + rand(-0.2, 0.2), 0.01, 1);
            }
            if (s.type === "path") {
              if (Math.random() < P) {
                for (const seg of s.segments) {
                  for (let i = 1; i < seg.length; i++)
                    seg[i] = clamp(seg[i] + rand(-0.15, 0.15), 0, 1);
                }
              }
              if (Math.random() < P * 0.2 && s.segments.length > 2)
                s.segments.splice(randInt(1, s.segments.length - 1), 1);
              if (Math.random() < P * 0.2 && s.segments.length < 24)
                s.segments.splice(randInt(1, s.segments.length), 0, [
                  "L",
                  rand(0.15, 0.85),
                  rand(0.0, 1.0),
                ]);
            }
          }
        }
        return g;
      }

      /* UI grid */
      const gridEl = document.getElementById("grid");
      let parentGen = randomGenotype();
      const mutationPlan = [0.1, 0.1, 0.1, 0.3, 0, 0.3, 0.5, 0.5, 0.5];
      function clearGrid() {
        gridEl.innerHTML = "";
      }
      function renderGrid() {
        clearGrid();
        const gens = mutationPlan.map((P) =>
          P === 0 ? deep(parentGen) : mutateGenotype(parentGen, P),
        );
        gens.forEach((g, idx) => {
          const cell = document.createElement("div");
          cell.className = "cell";
          if (idx === 4) cell.style.outline = "2px solid rgba(110,231,183,.12)";
          const svgEl = genotypeToSvgElement(g, 1024);
          cell.appendChild(svgEl);
          const badge = document.createElement("div");
          badge.className = "badge";
          badge.textContent =
            idx === 4 ? "Parent" : `P=${mutationPlan[idx].toFixed(1)}`;
          cell.appendChild(badge);
          cell.addEventListener("click", () => {
            if (idx !== 4) {
              parentGen = g;
              renderGrid();
            }
          });
          gridEl.appendChild(cell);
        });
      }

      document.getElementById("saveSvg").addEventListener("click", () => {
        const svg = genotypeToSvgElement(parentGen, 2048);
        const s = new XMLSerializer().serializeToString(svg);
        const blob = new Blob([s], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "evo.svg";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });
      document.getElementById("savePng").addEventListener("click", () => {
        const svg = genotypeToSvgElement(parentGen, 2048);
        const s = new XMLSerializer().serializeToString(svg);
        const img = new Image();
        const blob = new Blob([s], { type: "image/svg+xml" });
        const url = URL.createObjectURL(blob);
        img.onload = () => {
          const c = document.createElement("canvas");
          c.width = 2048;
          c.height = 2048;
          const ctx = c.getContext("2d");
          ctx.drawImage(img, 0, 0);
          c.toBlob((b) => {
            const u = URL.createObjectURL(b);
            const a = document.createElement("a");
            a.href = u;
            a.download = "evo.png";
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(u);
          }, "image/png");
          URL.revokeObjectURL(url);
        };
        img.src = url;
      });
      document.getElementById("randomize").addEventListener("click", () => {
        parentGen = randomGenotype();
        renderGrid();
      });

      renderGrid();
    </script>
  </body>
</html>
